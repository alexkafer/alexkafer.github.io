{"componentChunkName":"component---src-pages-course-index-js","path":"/course/","matchPath":"/course/*","result":{"data":{"contentfulCourses":{"id":"5e543b3b-a195-5695-9a77-d6bf3deb4bef","classTitle":"CSCI 5611: Animation and Planning in Games","classDescription":{"id":"270f0b23-b45e-5510-b6e8-cd59973b440d","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Theory behind algorithms used to bring virtual worlds to life. Computer animation topics. Real-time, interactive techniques used in modern games. Physically-based animation, motion planning, character animation, simulation in virtual worlds.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"classDate":"Spring 2020","projects":[{"id":"31cd6322-63e4-532c-9168-d3765b4a0e2f","projectTitle":"Bouncing Ball (Assignment 1 - Check In)","projectDescription":{"id":"3292cb73-fc16-50ab-9e5b-c4efc951ace6","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"3D OpenGL rendering of a bouncing ball. It uses OpenGL, GLEW, GLM, and a custom shader manager based off of a homework assignment for CSC5607 Fundamentals of Computer Graphics by taught by Dr. Victoria Interrante. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"This check in includes multiple camera angles. Pressing B tracks the ball while aligning the camera and increasing the projection draw distance keeping the platform in view. Pressing R resets the view to an orbiting camera.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"A fragment shader and vertex shader was used to calculate lighting. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"68SmG04rwA0","projectUrl":"https://github.com/alexkafer/opengl-animation/tree/assignment1-checkin"},{"id":"20d9d548-d792-55e4-84f4-5c55f020a27c","projectTitle":"Particle Systems (Assignment 1) ","projectDescription":{"id":"74d0bfba-ea38-5e15-b08b-a3bd686737f5","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Assignment one focused on building a particle system. I developed two demonstrations: ","nodeType":"text"},{"data":{"uri":"https://github.com/alexkafer/opengl-animation/tree/assignment1-water"},"content":[{"data":{},"marks":[],"value":"a fire hydrant","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" with water and a ","nodeType":"text"},{"data":{"uri":"https://github.com/alexkafer/opengl-animation/tree/assignment1-fire"},"content":[{"data":{},"marks":[],"value":"camp site","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" with fire.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c3fGyDrG4h1JQzbvN9FVOcV","type":"Asset","createdAt":"2020-02-07T06:44:38.191Z","updatedAt":"2020-02-07T06:44:38.191Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"3fGyDrG4h1JQzbvN9FVOcV"},"fields":{"title":{"en-US":"Camp fire"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/3fGyDrG4h1JQzbvN9FVOcV/c2439da13481b477586461a93c346061/Screen_Shot_2020-02-06_at_11.42.08_PM.png","details":{"size":102098,"image":{"width":498,"height":503}},"fileName":"Screen Shot 2020-02-06 at 11.42.08 PM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c4tHt0SsikmeBWk8WhjLI3V","type":"Asset","createdAt":"2020-02-07T06:46:26.727Z","updatedAt":"2020-02-07T06:46:26.727Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"4tHt0SsikmeBWk8WhjLI3V"},"fields":{"title":{"en-US":"Water Hydrant"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/4tHt0SsikmeBWk8WhjLI3V/5808bc80d97ad18986a5ae33f9ae53c3/Screen_Shot_2020-02-07_at_12.46.02_AM.png","details":{"size":122369,"image":{"width":498,"height":503}},"fileName":"Screen Shot 2020-02-07 at 12.46.02 AM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"I developed the animation in OpenGL with two separate GLSL shaders (one for phong illumination, and the other for particle rendering). I used tinyobjloader to load the 3D models and stb_image to load the textures. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The water simulation (without transparency) benchmarked at 212,408 particles at an average 36 frames per second on my laptop. With transparency (like the fire), I averaged ~50k particles at 40 frames per second. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"I attempted to use animated textures for the camp fire, but was unable to completely animate the textures by the due date. It did create a pretty interesting visuals though! ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Two required simulations in context. Water hydrant and Camp site fire","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"3D user-controlled camera (rotation and translation)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Particle obstacle interactions (water particles with the ball, cauldron interaction with the fire)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Translucent particles","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"All four performance benchmarking (212,408 particles at an average 36 fps, thanks C++!)  ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"[Attempted, see video] textured sprites for particles ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Art Contest submission","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"Water Simulation","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c4OX6L9dtaz9pKN0rdBoqfE","type":"Asset","createdAt":"2020-02-07T06:36:55.858Z","updatedAt":"2020-02-07T06:36:55.858Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"4OX6L9dtaz9pKN0rdBoqfE"},"fields":{"title":{"en-US":"Water Simulation"},"file":{"en-US":{"url":"//videos.ctfassets.net/i2v469lal2ph/4OX6L9dtaz9pKN0rdBoqfE/c442dcd69225cfb5ea47e7c579abeba3/Screen_Recording_2020-02-07_at_12.23.15_AM.mov","details":{"size":10377065},"fileName":"Screen Recording 2020-02-07 at 12.23.15 AM.mov","contentType":"video/quicktime"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"Fire Simulation","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c74vqJm3HXfdmWk1AZNwEFh","type":"Asset","createdAt":"2020-02-07T06:41:29.906Z","updatedAt":"2020-02-07T06:41:29.906Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"74vqJm3HXfdmWk1AZNwEFh"},"fields":{"title":{"en-US":"Normal fire"},"file":{"en-US":{"url":"//videos.ctfassets.net/i2v469lal2ph/74vqJm3HXfdmWk1AZNwEFh/9ad8a12c6b295190e7fbb6bdf0ce24fd/normal-fire.mov","details":{"size":4073565},"fileName":"normal-fire.mov","contentType":"video/quicktime"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c7qMpP6opl1kVhfNiHpjiUu","type":"Asset","createdAt":"2020-02-07T06:40:13.730Z","updatedAt":"2020-02-07T06:40:13.730Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"7qMpP6opl1kVhfNiHpjiUu"},"fields":{"title":{"en-US":"On Fire!"},"file":{"en-US":{"url":"//videos.ctfassets.net/i2v469lal2ph/7qMpP6opl1kVhfNiHpjiUu/84cbdd95e43db50afe682d687b0c7289/Screen_Recording_2020-02-06_at_11.32.01_PM.mov","details":{"size":12538960},"fileName":"Screen Recording 2020-02-06 at 11.32.01 PM.mov","contentType":"video/quicktime"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Texture Issues","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c6HFTZZbJoM0C4rJLSk7p4z","type":"Asset","createdAt":"2020-02-07T06:35:53.672Z","updatedAt":"2020-02-07T06:35:53.672Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"6HFTZZbJoM0C4rJLSk7p4z"},"fields":{"title":{"en-US":"Texture Issues "},"file":{"en-US":{"url":"//videos.ctfassets.net/i2v469lal2ph/6HFTZZbJoM0C4rJLSk7p4z/02822718b0bbab465bc0117c8a163cb1/Screen_Recording_2020-02-06_at_11.21.45_PM.mov","details":{"size":4410037},"fileName":"Screen Recording 2020-02-06 at 11.21.45 PM.mov","contentType":"video/quicktime"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The biggest difficulties I encountered were concerning the multiple shaders, loading the OBJ files, and wrangling all the vertex buffer objects. I had extremely limited experience with OpenGL (just a few weeks near the end of CSCI 5607), so the entire process was a learning experience. This submission doesn't have the polish I would like it to have had, but I feel like I understand OpenGL significantly more after this assignment.   ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":null,"projectUrl":null},{"id":"06fab306-bdc8-5063-b808-06fb6501ab71","projectTitle":"Vertical Spring System (Assignment 2 - Check In)","projectDescription":{"id":"d0e760b6-b283-53ed-851f-5e0de4321fda","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"In this assignment we will be creating a cloth simulation. For assignment 2 check in, we were expected to create a vertical thread modeled after a system of springs.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"In addition to the spring simulation, I also added a few additional features to my base simulation:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Added the ability to press 'p' to enable picking mode, then drag to move draggable objects (accomplished via ray-casting)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Added the ability to press SPACE and SHIFT move up and down, respectively. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Smoothed the camera movement by moving a camera target, then linearly interpolating the eye position to that target. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Began investigating spatial hashing for object collisions. Inspired by ","nodeType":"text"},{"data":{"uri":"https://matthias-research.github.io/pages/publications/tetraederCollision.pdf"},"content":[{"data":{},"marks":[],"value":"Optimized Spatial Hashing for Collision Detection of Deformable Objects","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":". The code has been commented out for this check in submission. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"TEpXw5OM7zg","projectUrl":"https://github.com/alexkafer/opengl-animation/tree/assignment2-checkin"},{"id":"5ed2dba8-ec50-5cc8-9836-464baee4475e","projectTitle":"Physical Simulation (Assignment 2)","projectDescription":{"id":"4fc034f1-e31c-5b75-8e4c-a16baa870438","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"In this assignment we focused on physical simulations. I created a semi-advanced cloth as well as a 30x30x30 3D Eulerian Fluid simulation.   ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Realtime rendering (see video for FPS, usually ~50/60)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"3D rendering, with a user-controlled camera (WASD, space to go up, shift to go down)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"3D Mass-spring cloth simulation","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Drag-terms (see cloth dragging on the table)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"1-way cloth-object interaction with the rectangular table","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Demo video shows a 30x30 cloth with obstacle interaction. Demo also shows a 60x60 flag.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Eulerian Integrator","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Textured simulated objects (red cloth, American Flag)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Thread-parallel implementation with OpenMP. Allows the stable 60x60 flag. Maxes out at a 200x200 flag, but the threads become too long to render and increasing K makes the simulation unstable. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Attempted a spatial-data structure. Did not complete self-collision, so spatial-data structure was untested. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Billowing.blowing wind effect simulated with aerodynamic drag.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Attempted self-collision. Ran into issues with the triangle intersection and did not complete in time.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Extended the Stam GDC '03 paper with a 3D Eulerian fluid simulation. The demo shows the first attempt with water, which did not turn out very well. I had some issues imposing external forces (gravity) without the water disappearing, so I pivoted the fluid to be a smoke/fog. The demo shows a 30x30x30 simulation in the context of a steam engine locomotive. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"In the additional video below, I demonstrate a 38x38x38 3D Eulerian fluid simulation at 30fps which  exceeds the highest performance expectation of 200x200 (54,872 > 40,000).","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Art contest submission.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c1KLEkYl1S7DdxdFudX7QR5","type":"Asset","createdAt":"2020-02-28T06:22:19.053Z","updatedAt":"2020-02-28T06:22:19.053Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"1KLEkYl1S7DdxdFudX7QR5"},"fields":{"title":{"en-US":"38x38x38 3D Fluid"},"file":{"en-US":{"url":"//videos.ctfassets.net/i2v469lal2ph/1KLEkYl1S7DdxdFudX7QR5/4ec272336caf15e571f8e671e6fbc5ee/Screen_Recording_2020-02-28_at_12.19.15_AM.mov","details":{"size":3962407},"fileName":"Screen Recording 2020-02-28 at 12.19.15 AM.mov","contentType":"video/quicktime"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"At any time during the simulation, press P to toggle between picking and flying around. When picking, the mouse ray casts to the cloth. The controls of the 3D Eulerian fluid is E to emit smoke. G for gravity. And the arrow keys for directional forces. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The code is split between three branches in github. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"'assignment2' is the cloth table. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"'assignment2-flag' is the flag","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"'assignment2-fluid-3D' is the 3D simulation.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"Resources used:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"C++ / OpenGL (with shaders)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"GLM for vectors","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"OpenMP for thread processing","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Tinyobjloader for loading obj","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"stb_image for texture loading","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"Reference: Jos Stam, \"Real-Time Fluid Dynamics for Games\". Proceedings of the Game Developer Conference, March 2003.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"\"A Fast Triangle-Triangle Intersection Test\" by Tomas Moller, 1997.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"TfGQ1cveNMo","projectUrl":"https://github.com/alexkafer/opengl-animation/tree/assignment2"},{"id":"056e8252-bdc8-53d1-a638-2e06b7f0206f","projectTitle":"Motion Planning (Assignment 3 - Check In)","projectDescription":{"id":"4c15e0e4-1617-5df8-92b4-b5c61212716e","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"In this check-in, I have created a 0.5m radius game character is in a large 20m x 20m room.  The character starts at the bottom left (-9,-9) and when the user presses N (for navigate, it navigates to the top right (9,9).  There is a single obstacle in the room, represented by a sphere of radius 2 meters at coordinates (0,0).  The user can also press M to navigate the character back to -9,-9 for a looping demo. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"I am using a probabilistic roadmap (PRM) to plan a path for the agent from the start to the goal. It uses Dijkstra's algorithm for the path finding.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The code is in the #assignment3-checkin branch of my main opengl-animation repository. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"zbM9RtAAGow","projectUrl":"https://github.com/alexkafer/opengl-animation/tree/assignment3-checkin"},{"id":"76e4d9b5-614a-576b-9fee-4dc3b444bc07","projectTitle":"Motion Planning (Assignment 3)","projectDescription":{"id":"cb768ea8-44f5-5f36-a56c-83eb70df47f3","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"In this assignment, we focused on building a motion planning framework used to animate groups of agents navigating in complex environments. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"For my assignment, I implemented:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Boids local interaction technique ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"PRM and A* global navigation strategy","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"The roadmap accounts for the extent of the agent with multiple obstacles","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Agents are able to successfully navigate through environments with local minima","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Nicely rendered 3D scenes with models to give context","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Supports full 3D navigation with 3D flocking birds ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"The user can add and move obstacles at run time (Press \"I\" to interact","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Dynamically choose agent start and goals at run time","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"The agent is animated as a virtual walking character ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Character Rigging (played Mo-Cap in character animation file)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Path smoothing (walk to the furthest visible node on path)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Allow agents to rotate to reach a goal","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"Other things, not necessary related to the assignment:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Generates oriented boundry boxes for each entity! Includes ray casting for selecting items, and OBB-OBB collision test","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"ASSIMP importer with bone support. Bone matrixes are calculated on the GPU.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"ASSIMP model animation support","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://github.com/alexkafer/opengl-animation/tree/precedually-generated"},"content":[{"data":{},"marks":[],"value":"Procedurally generated tile world!","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" I didn't continue with it, but it was really fun to make. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c3EKfdeQS4o8485KlF1UD99","type":"Asset","createdAt":"2020-04-02T07:42:52.419Z","updatedAt":"2020-04-02T07:42:52.419Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"3EKfdeQS4o8485KlF1UD99"},"fields":{"title":{"en-US":"Procedurally generated tile world"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/3EKfdeQS4o8485KlF1UD99/ab26a4bcb1c42a3d5e03885bf01b919d/Screen_Shot_2020-03-23_at_1.26.27_PM.png","details":{"size":483918,"image":{"width":2032,"height":1169}},"fileName":"Screen Shot 2020-03-23 at 1.26.27 PM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Bounding box rendering","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Controls","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Press \"I\" to interact. Click to select an item (the bounding box will turn RED).\nClick and drag any obstacle. Rotate a selected obstacle with LEFT and RIGHT arrow keys.\nClick anywhere on the ground to direct a selected player entity.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Resources used:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Assimp for 3D models","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"OBB information from \"Intersection method from Real-Time Rendering and Essential Mathematics for Games\"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Difficulties:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Plenty! First, importing modules required me to write my own ASSIMP importer. Since ASSIMP creates nodes in a tree format, I needed to re-write how my phong renderer worked. ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"The Oriented Bounding Boxes were a pain, specifically with all the change of coordinate spaces. If I had more time I would've transformed the bounding boxes with animations, allowing for the player to get \"skinny\" and slip through smaller paths. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"For sweeping OBBs, I ended up just using small steps and testing a LERPed and SLERPed position vector and quaternion.","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"I originally had the oriented bounding boxes using their own modelview matrix, but simulating the object's extent around other objects caused this to quickly break down.  This is a problem that was hard to track down because the bounding box renderer also used the modelview matrix. Eventually I just bit the bullet at switched to calculating the bounding box separate from the object's rendering logic.    ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"Ny5dAI1T5xI","projectUrl":"https://github.com/alexkafer/opengl-animation/tree/assignment3"},{"id":"59c0691a-75bb-5c8d-a277-6f951dcb37ec","projectTitle":"Procedurally Generated Planet (Final Project)","projectDescription":{"id":"ee402b79-d3b3-53eb-89d2-de6f8ed577d9","json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"For the final project, I wanted to implement Keplerian orbits with procedurally generated planets. This was an individual project.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"\n","nodeType":"text"},{"data":{},"marks":[{"type":"bold"}],"value":"Current State of the Art ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://www.youtube.com/watch?v=QN39W020LqU&list=PLFt_AvWsXl0cONs3T0By4puYy6GM22ko8"},"content":[{"data":{},"marks":[],"value":"Procedurally generated planet in Unity [ Tutorial ]","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://oskarstalberg.com/game/planet/planet.html"},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://oskarstalberg.com/game/planet/planet.html"},"content":[{"data":{},"marks":[],"value":"Buildable procedurally generated planet (uses Unity)","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://hilkojj.nl/"},"content":[{"data":{},"marks":[],"value":"Cphere, rendered planet using a custom framework","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":"https://lab.nstmf.org/gravity"},"content":[{"data":{},"marks":[],"value":"A beautiful web demo that describes gravitational attraction","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":" https://transfercalculator.com/"},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"},{"data":{"uri":" https://transfercalculator.com/"},"content":[{"data":{},"marks":[],"value":"Visual orbital transfer calculator that describes a number of different transfers in the realworld","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Rendering Improvements to the State-of-the-Art","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Cphere had some of the best rendering. For the planet, my goal was to implement\nsimilar ideas. I was only able to view the WebGL version, so everything had to\nbe re-implemented by inspecting the OpenGL ES sources. In their demo, almost\nevery renderer is strictly fixed around 0,0,0 and for only one planet. I was\nable to generalize the water rendering, the cloud translations, and lens flare.\nI was also able to reuse the textures used in the WebGL demo, which was really\nnice since I’m not an artist myself. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"\nMy implementation improves upon that demo by breaking up the shaders into separate renderers and generalizing the vector math algorithms around a given point instead of the\nworld origin.  I also expanded the shadow pass to run at the scale of planets and implemented the same scene graph and bounding box rendering system I had in my previous assignments. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"tjXydIUWdMn7nRoVK7MIK","type":"Asset","createdAt":"2020-05-14T02:12:48.012Z","updatedAt":"2020-05-14T02:12:48.012Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"tjXydIUWdMn7nRoVK7MIK"},"fields":{"title":{"en-US":"Planet Terrain Mesh"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/tjXydIUWdMn7nRoVK7MIK/7351670652e1fd327528963697338586/Screen_Shot_2020-05-13_at_7.30.57_PM.png","details":{"size":486270,"image":{"width":1192,"height":1140}},"fileName":"Screen Shot 2020-05-13 at 7.30.57 PM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"I personally didn’t like the way the planetary sphere was implemented in the\nterrain generation (landmasses were generated separately from the planet and took\na very long time to generate something). As an improvement, I wanted to use a\nSimplex noise function as an elevation on each of the sphere’s vertices. Since it\nsimply deformed the planet’s mesh, this was much easier to work with, and I\nimagine less computationally intensive.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The cphere demo used a planetary sphere based off rings stacked on top of each other.\nThis has a drawback of bunching up density textures near the top, which due to\nthe simplex noise function meant there was more detail near the poles. My\nimplementation uses a CubeSphere instead. This effectively evenly distributes\nthe vertexes and makes drawing textures easier. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The last rendering improvement I made was implementing a multiple planet camera. I used\nthe Three.JS trackball orbit camera algorithms to improve the Cphere camera\ncontroller. Much like how the trackball has a center focus area, my planet\ncamera is centered on the planet that is currently selected. The selection algorithm\nis a simple ray sphere intersection test from the point where the user clicked.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"xadc8cI5zW2BlD4aumsCJ","type":"Asset","createdAt":"2020-05-14T01:32:53.982Z","updatedAt":"2020-05-14T01:32:53.982Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"xadc8cI5zW2BlD4aumsCJ"},"fields":{"title":{"en-US":"Planet with Shadow of Moon"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/xadc8cI5zW2BlD4aumsCJ/d0b91172089f8e6f160be3e9063dc1d1/Screen_Shot_2020-05-13_at_7.54.38_PM.png","details":{"size":138319,"image":{"width":477,"height":251}},"fileName":"Screen Shot 2020-05-13 at 7.54.38 PM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The cphere planet rotates the based on longitude and latitude. My improvement uses\nthe sample longitude and latitude ideas (which simplifies the zoom and smooth\nrotation around the planet), but outputs a camera position and quaternions,\nwhich I can then smoothly LERP and SLERP to if a new planet is selected. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Keplerian Orbits ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Most planetary games use circular orbits, which visually work fine. I wanted to\nimplement Keplerian orbits, which utilize 6 orbital parameters to fully define\nan elliptical orbit. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The transfer calculator relies on pre-calculated, real life planetary data to represent the\norbits and was implemented in JavaScript. My goal was to remove the physical dependence\nof the algorithms as well as calculate the parameters based on the starting\nconfigurations.\n\n","nodeType":"text"},{"data":{},"marks":[{"type":"bold"}],"value":"What worked","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Terrain generation! I was able to implement ImGUI to make real-time adjustments and\nregenerate the currently selected planet. See the screenshot below:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c2JviVlumQtFzp7ETyFNiWC","type":"Asset","createdAt":"2020-05-14T02:08:18.887Z","updatedAt":"2020-05-14T02:08:18.887Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"2JviVlumQtFzp7ETyFNiWC"},"fields":{"title":{"en-US":"Using imGUI to adjust on the fly"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/2JviVlumQtFzp7ETyFNiWC/47f57d79b396631a772f6a2b28b31286/Screen_Shot_2020-05-13_at_8.58.26_PM.png","details":{"size":2422975,"image":{"width":2874,"height":1436}},"fileName":"Screen Shot 2020-05-13 at 8.58.26 PM.png","contentType":"image/png"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"In the end, the key algorithm that worked best for me was using two types of Simplex\nnoise. The first was four samples of normal [-1, 1] ranged simplex noise to\ncreate the continents. The strength affects the total magnitude, the base\nroughness sets the initial frequency and the roughness multiplies frequency\nevery layer. I also include a min-value to maintain the spherical shape near\nthe oceans. Once the continents were created, I used a ridged noise function\nthat is 1 - absolute value of the  [-1,\n1] range. This creates the mountain ranges, with similar parameters for each\nlayer. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The shadow map mostly worked, as long as the sun is far away (a.k.a acts like a\ndirectional light source).","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Multiple stable Keplerian orbits and rendering multiple planets! I was even able to get moons on my planets! See below:\n","nodeType":"text"}],"nodeType":"paragraph"},{"data":{"target":{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"i2v469lal2ph","contentful_id":"i2v469lal2ph"}},"id":"c4yZjC7nS9LuYBzdmwaE5Cd","type":"Asset","createdAt":"2020-05-14T00:22:27.250Z","updatedAt":"2020-05-14T00:22:27.250Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment","contentful_id":"master"}},"revision":1,"contentful_id":"4yZjC7nS9LuYBzdmwaE5Cd"},"fields":{"title":{"en-US":"Animated Orbit"},"file":{"en-US":{"url":"//images.ctfassets.net/i2v469lal2ph/4yZjC7nS9LuYBzdmwaE5Cd/eb17d734b514ac70361f90df3ac853bc/ezgif-3-7b8a66949c53.gif","details":{"size":1525596,"image":{"width":600,"height":377}},"fileName":"ezgif-3-7b8a66949c53.gif","contentType":"image/gif"}}}}},"content":[],"nodeType":"embedded-asset-block"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"What didn’t work","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Camera motion between planets can add unnecessary rotations. I believe this is due to quaternion rotations conflicting with the longitude & latitudes rotations that I use\nto determine where on the new planet I should animate to. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Shadow mapping breaks when the sun is in the center. This is because the sun doesn’t\nknow which direction to project it’s camera, so the camera becomes undefined.  More on this in the future work section.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Objects that are orbiting something often collide over time. Since orbital\nparameters are constant, finding the correct ones that wouldn’t collide on planet\ngeneration would require me to forward simulate all of the possible orbital\npaths. This is a problem that I wasn’t able to come up with a good solution for.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Currently, this system only supports one body problems. As more planets are added, those\nplanets would have their own gravitational influence. I attempted to simplify this\nbehavior using spheres of influence (if a mass is far enough away, the gravity\nof another won’t influence it), but I was unable to get any noticeable results.\n","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Computational Bottlenecks","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"As we add more orbits and simulate them forward, the computational intensities would also\nincrease. As I was unable to get orbital collision checking to work, but if that would be one of the first major bottlenecks.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"The planet meshes themselves would also be a bottleneck and would need some sort of\ntessellation or scene graph to only render planets in view or at optimal detail.\nAdditionally, far away planets (enough where terrain detail can’t be seen) could\nbe replaced with a quad to simplify rendering.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[{"type":"bold"}],"value":"Future work","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"In the future, I would like to incorporate transfer calculations into the simulation. It was\nsomething I was planning since the beginning, but I was unable to get it\nworking in a way I was confident showing off. Turns out rocket science is hard.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"I would also like to figure out a way for the shadow mapping to work when the sun is in\nthe center. My initial ideas are to use something like a panorama camera, or let\nthe problem solve itself it ray-tracing. ","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Finally, I would like to get more realistic terrain texturing. Grass is currently being determined via a simplex fractal noise and the rest is determined based on height.  I would like to expand the noise-based texturing out to the different texture times, as currently the rest are determined based on height.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Resources:","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"OpenGL, GLFW, C++","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"GLM ","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"OpenMP for thread processing","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"FastNoise","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"Assimp (model)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"stb_image for texture loading","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"OpenCV (for video export)","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"},{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"ImGUI for debugging and real time planet generation tweaking","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"list-item"}],"nodeType":"unordered-list"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"youtubeID":"_-fuyrRtJHM","projectUrl":"https://github.com/alexkafer/planets"}]}},"pageContext":{"matchPath":"/course/*"}}}